<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tärning eller Klocka</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f6f7; color: #111; }
    .app { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .card { background: #fff; border-radius: 14px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.06); }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    label { font-size: 14px; }
    input[type="number"], select {
      font-size: 14px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; background: #fff;
    }
    button {
      font-size: 14px; padding: 10px 14px; border: 0; border-radius: 12px; background: #111; color: #fff;
      cursor: pointer;
    }
    button.secondary { background: #e9e9ea; color: #111; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .hint { color: #666; font-size: 13px; margin-top: 8px; }
    .spacer { height: 10px; }
    .hidden { display: none !important; }

    /* Visualization */
    .vizWrap {
      margin-top: 14px;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      height: min(78vh, 760px);
    }
    .vizTop { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; }
    .vizInfo { font-size: 15px; font-weight: 600; }
    .vizCanvasWrap {
      background: #fff; border-radius: 14px; box-shadow: inset 0 0 0 1px #eee;
      overflow: hidden; display:flex;
    }
    canvas { width: 100%; height: 100%; display:block; background: white; }
    .vizBottom { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: center; }
    .pill { padding: 8px 12px; background:#f0f0f1; border-radius: 999px; font-size: 13px; color:#222; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card" id="setupCard">
      <h1>Tärning eller Klocka</h1>

      <div class="row">
        <div class="col">
          <label><input type="radio" name="mode" value="dice" checked> Slå tärning</label>
          <label><input type="radio" name="mode" value="clock"> Visa klocka (slumpad tid)</label>
        </div>

        <div class="col" style="margin-left:auto;">
          <label><input id="showAnswer" type="checkbox" checked> Visa facit (summa / klockslag)</label>
          <div class="hint">Ljud spelas när du trycker på knappar (webbläsare kräver användarklick).</div>
        </div>
      </div>

      <div class="spacer"></div>

      <div class="row" id="diceOptions">
        <label>Antal tärningar:</label>
        <input id="numDice" type="number" min="1" max="24" value="2" />
      </div>

      <div class="row hidden" id="clockOptions">
        <label>Minutintervall:</label>
        <select id="interval">
          <option>1</option>
          <option selected>5</option>
          <option>10</option>
          <option>15</option>
          <option>20</option>
          <option>30</option>
          <option>60</option>
        </select>
      </div>

      <div class="spacer"></div>
      <div class="row">
        <button id="openBtn">Öppna</button>
      </div>

      <div class="hint">Tips: På mobilen kan du rotera skärmen. Du kan också använda helskärmsknappen i visualiseringen.</div>
    </div>

    <div class="card hidden" id="vizCard">
      <div class="vizWrap">
        <div class="vizTop">
          <div class="vizInfo" id="vizTitle">—</div>
          <div class="row">
            <span class="pill" id="answerPill">Facit: —</span>
            <button class="secondary" id="fullscreenBtn">Helskärm</button>
            <button class="secondary" id="backBtn">Tillbaka</button>
          </div>
        </div>

        <div class="vizCanvasWrap" id="canvasContainer">
          <canvas id="canvas"></canvas>
        </div>

        <div class="vizBottom">
          <button id="actionBtn">—</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Ljud (lägg dina filer i sounds/) -->
  <audio id="diceAudio" preload="auto">
    <source src="sounds/dice.wav" type="audio/wav">
  </audio>
  <audio id="clockAudio" preload="auto">
    <source src="sounds/clock.wav" type="audio/wav">
  </audio>

<script>
(() => {
  // ---------- State ----------
  let mode = "dice";
  let showAnswer = true;

  // Dice state
  let diceN = 2;
  let diceValues = [];
  let diceAnim = null;

  // Clock state
  let interval = 5;
  let clockTime = { h: 0, m: 0 }; // 0-11, 0-59
  let clockAngles = { hour: -Math.PI/2, min: -Math.PI/2 };
  let clockAnim = null;

  // ---------- Elements ----------
  const setupCard = document.getElementById("setupCard");
  const vizCard = document.getElementById("vizCard");
  const diceOptions = document.getElementById("diceOptions");
  const clockOptions = document.getElementById("clockOptions");

  const openBtn = document.getElementById("openBtn");
  const backBtn = document.getElementById("backBtn");
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const actionBtn = document.getElementById("actionBtn");

  const showAnswerEl = document.getElementById("showAnswer");
  const numDiceEl = document.getElementById("numDice");
  const intervalEl = document.getElementById("interval");

  const vizTitle = document.getElementById("vizTitle");
  const answerPill = document.getElementById("answerPill");

  const canvasContainer = document.getElementById("canvasContainer");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const diceAudio = document.getElementById("diceAudio");
  const clockAudio = document.getElementById("clockAudio");
  let clockStopTimer = null;

  // ---------- Helpers ----------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function resizeCanvasToContainer() {
    const rect = canvasContainer.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }

  function playAudio(audioEl) {
    try {
      audioEl.pause();
      audioEl.currentTime = 0;
      audioEl.play().catch(()=>{ /* ignore autoplay issues */ });
    } catch {}
  }

  function stopAudio(audioEl) {
    try { audioEl.pause(); audioEl.currentTime = 0; } catch {}
  }

  function setFacit(text) {
    if (!showAnswer) {
      answerPill.textContent = "Facit: (dolt)";
      return;
    }
    answerPill.textContent = "Facit: " + text;
  }

  // ---------- UI wiring ----------
  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener("change", () => {
      mode = document.querySelector('input[name="mode"]:checked').value;
      diceOptions.classList.toggle("hidden", mode !== "dice");
      clockOptions.classList.toggle("hidden", mode !== "clock");
    });
  });

  showAnswerEl.addEventListener("change", () => {
    showAnswer = !!showAnswerEl.checked;
  });

  numDiceEl.addEventListener("change", () => {
    diceN = clamp(parseInt(numDiceEl.value || "2", 10), 1, 24);
    numDiceEl.value = diceN;
  });

  intervalEl.addEventListener("change", () => {
    interval = parseInt(intervalEl.value, 10);
  });

  openBtn.addEventListener("click", () => {
    showAnswer = !!showAnswerEl.checked;
    diceN = clamp(parseInt(numDiceEl.value || "2", 10), 1, 24);
    interval = parseInt(intervalEl.value, 10);

    setupCard.classList.add("hidden");
    vizCard.classList.remove("hidden");

    resizeCanvasToContainer();
    if (mode === "dice") startDiceView();
    else startClockView();
  });

  backBtn.addEventListener("click", () => {
    stopAllAnimations();
    setupCard.classList.remove("hidden");
    vizCard.classList.add("hidden");
  });

  fullscreenBtn.addEventListener("click", async () => {
    try {
      if (!document.fullscreenElement) {
        await vizCard.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    } catch {}
  });

  window.addEventListener("resize", () => {
    if (!vizCard.classList.contains("hidden")) {
      resizeCanvasToContainer();
      redraw();
    }
  });

  // ---------- Dice ----------
  function startDiceView() {
    vizTitle.textContent = "Tärningar";
    actionBtn.textContent = "Slå igen";
    diceValues = Array.from({length: diceN}, () => randInt(1,6));
    setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
    redraw();

    actionBtn.onclick = () => rollDiceAnimated();
  }

  function rollDiceAnimated() {
    stopAllAnimations();
    playAudio(diceAudio);

    const duration = 900; // ms
    const start = performance.now();
    const final = Array.from({length: diceN}, () => randInt(1,6));

    function frame(t) {
      const p = clamp((t - start)/duration, 0, 1);
      const ease = 1 - (1 - p)*(1 - p);

      // under animation: slumpa snabbt + jitter som minskar
      if (p < 1) {
        diceValues = Array.from({length: diceN}, () => randInt(1,6));
      } else {
        diceValues = final;
      }

      redraw({ diceJitter: (1 - ease) });

      if (p < 1) diceAnim = requestAnimationFrame(frame);
      else {
        diceAnim = null;
        setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
      }
    }
    diceAnim = requestAnimationFrame(frame);
  }

  function drawDie(x, y, size, value, jitterScale) {
    const j = (size * 0.08) * jitterScale;
    const dx = (Math.random()*2 - 1) * j;
    const dy = (Math.random()*2 - 1) * j;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.07)";
    roundRect(x+6+dx, y+6+dy, size, size, size*0.12, true, false);

    // body
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = Math.max(2, size/40);
    roundRect(x+dx, y+dy, size, size, size*0.12, true, true);

    // pips
    const margin = size * 0.22;
    const cx = [x+dx+margin, x+dx+size/2, x+dx+size-margin];
    const cy = [y+dy+margin, y+dy+size/2, y+dy+size-margin];
    const r = Math.max(2, size*0.06);

    const pips = {
      1: [[1,1]],
      2: [[0,0],[2,2]],
      3: [[0,0],[1,1],[2,2]],
      4: [[0,0],[2,0],[0,2],[2,2]],
      5: [[0,0],[2,0],[1,1],[0,2],[2,2]],
      6: [[0,0],[2,0],[0,1],[2,1],[0,2],[2,2]],
    }[value] || [];

    ctx.fillStyle = "black";
    for (const [ix,iy] of pips) {
      ctx.beginPath();
      ctx.arc(cx[ix], cy[iy], r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function layoutDice() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const n = diceN;

    // välj grid nära kvadrat
    let cols = Math.ceil(Math.sqrt(n));
    let rows = Math.ceil(n / cols);

    const base = Math.min(w, h);
    const gap = Math.max(16, base * 0.03);
    const margin = Math.max(12, base * 0.05);

    const size = Math.floor(Math.min(
      (w - 2*margin - (cols-1)*gap)/cols,
      (h - 2*margin - (rows-1)*gap)/rows
    ));
    const dieSize = clamp(size, 60, 700);

    // block size and centering
    const blockW = cols*dieSize + (cols-1)*gap;
    const blockH = rows*dieSize + (rows-1)*gap;
    const baseX = (w - blockW)/2;
    const baseY = (h - blockH)/2;

    return { w, h, cols, rows, gap, margin, dieSize, baseX, baseY };
  }

  // ---------- Clock ----------
  function startClockView() {
    vizTitle.textContent = "Klocka";
    actionBtn.textContent = "Slumpa ny tid";

    clockTime = randomTime(interval);
    setClockAnglesInstant(clockTime);
    setFacit(formatTime(clockTime));
    redraw();

    actionBtn.onclick = () => newClockTimeAnimated();
  }

  function randomTime(interval) {
    const h = randInt(0, 11);
    const steps = Math.floor(60 / interval);
    const m = randInt(0, steps-1) * interval;
    return { h, m };
  }

  function formatTime(t) {
    let hh = t.h % 12;
    if (hh === 0) hh = 12;
    return String(hh).padStart(2,"0") + ":" + String(t.m).padStart(2,"0");
  }

  function setClockAnglesInstant(t) {
    const minAng = clampAngle(-Math.PI/2 + (t.m/60)*Math.PI*2);
    const hourAng = clampAngle(-Math.PI/2 + ((t.h%12)/12)*Math.PI*2 + (t.m/60)*(Math.PI*2/12));
    clockAngles.min = minAng;
    clockAngles.hour = hourAng;
  }

  function clampAngle(a) {
    const two = Math.PI*2;
    a = a % two;
    if (a < 0) a += two;
    return a;
  }

  function clockwiseDelta(start, target) {
    start = clampAngle(start);
    target = clampAngle(target);
    return (target - start + Math.PI*2) % (Math.PI*2);
  }

  function newClockTimeAnimated() {
    stopAllAnimations();

    // ljud max 2 sek
    playAudio(clockAudio);
    if (clockStopTimer) clearTimeout(clockStopTimer);
    clockStopTimer = setTimeout(() => stopAudio(clockAudio), 2000);

    const newT = randomTime(interval);

    const targetMin = clampAngle(-Math.PI/2 + (newT.m/60)*Math.PI*2);
    const targetHour = clampAngle(-Math.PI/2 + ((newT.h%12)/12)*Math.PI*2 + (newT.m/60)*(Math.PI*2/12));

    const startMin = clockAngles.min;
    const startHour = clockAngles.hour;

    const dMin = clockwiseDelta(startMin, targetMin);
    const dHour = clockwiseDelta(startHour, targetHour);

    const duration = 2000;
    const start = performance.now();

    function frame(t) {
      const p = clamp((t - start)/duration, 0, 1);
      const ease = 1 - (1 - p)*(1 - p);

      clockAngles.min = clampAngle(startMin + dMin*ease);
      clockAngles.hour = clampAngle(startHour + dHour*ease);

      redraw();

      if (p < 1) clockAnim = requestAnimationFrame(frame);
      else {
        clockAnim = null;
        clockTime = newT;
        setFacit(formatTime(clockTime));
      }
    }
    clockAnim = requestAnimationFrame(frame);
  }

  function drawClock() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const size = Math.min(w, h);

    const cx = w/2, cy = h/2;
    const r = size * 0.42;

    // face
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // markers + numbers (12 up)
    for (let i=0; i<12; i++) {
      const ang = -Math.PI/2 + i*(Math.PI*2/12);
      const x1 = cx + (r*0.88)*Math.cos(ang);
      const y1 = cy + (r*0.88)*Math.sin(ang);
      const x2 = cx + (r*0.98)*Math.cos(ang);
      const y2 = cy + (r*0.98)*Math.sin(ang);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.stroke();

      const num = ((i + 11) % 12) + 1;
      const tx = cx + (r*0.72)*Math.cos(ang);
      const ty = cy + (r*0.72)*Math.sin(ang);
      ctx.fillStyle = "#111";
      ctx.font = `${Math.max(12, r*0.10)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(num), tx, ty);
    }

    // hour hand
    ctx.strokeStyle = "#111";
    ctx.lineCap = "round";
    ctx.lineWidth = Math.max(4, r/18);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + (r*0.55)*Math.cos(clockAngles.hour),
               cy + (r*0.55)*Math.sin(clockAngles.hour));
    ctx.stroke();

    // minute hand
    ctx.lineWidth = Math.max(3, r/24);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + (r*0.80)*Math.cos(clockAngles.min),
               cy + (r*0.80)*Math.sin(clockAngles.min));
    ctx.stroke();

    // center dot
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(cx, cy, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // ---------- Rendering ----------
  function redraw(opts = {}) {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    ctx.clearRect(0,0,w,h);

    if (mode === "dice") {
      const L = layoutDice();
      const n = diceN;
      const cols = L.cols;
      const rows = Math.ceil(n/cols);

      // block centering
      const fullRows = Math.floor(n / cols);
      const lastCount = n % cols;

      const jitterScale = (opts.diceJitter ?? 0);

      for (let i=0; i<n; i++) {
        const row = Math.floor(i/cols);
        const col = i % cols;

        let rowBaseX = L.baseX;
        if (lastCount !== 0 && row === fullRows) {
          const lastW = lastCount * L.dieSize + (lastCount - 1) * L.gap;
          rowBaseX = (L.w - lastW)/2;
        }

        const x = rowBaseX + col*(L.dieSize + L.gap);
        const y = L.baseY + row*(L.dieSize + L.gap);
        drawDie(x, y, L.dieSize, diceValues[i] ?? 1, jitterScale);
      }
    } else {
      drawClock();
    }
  }

  function stopAllAnimations() {
    if (diceAnim) cancelAnimationFrame(diceAnim);
    if (clockAnim) cancelAnimationFrame(clockAnim);
    diceAnim = null;
    clockAnim = null;
  }

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function roundRect(x, y, w, h, r, fill, stroke) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

})();
</script>
</body>
</html>
