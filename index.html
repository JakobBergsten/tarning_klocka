<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>T√§rning eller Klocka</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f6f7; color: #111; }
    .app { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .card { background: #fff; border-radius: 14px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.06); }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    label { font-size: 14px; }
    input[type="number"], select {
      font-size: 14px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; background: #fff;
    }
    button {
      font-size: 14px; padding: 10px 14px; border: 0; border-radius: 12px; background: #111; color: #fff;
      cursor: pointer;
    }
    button.secondary { background: #e9e9ea; color: #111; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .hint { color: #666; font-size: 13px; margin-top: 8px; }
    .spacer { height: 10px; }
    .hidden { display: none !important; }

    /* Visualization */
    .vizWrap {
      margin-top: 14px;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      height: min(78vh, 760px);
    }
    .vizTop { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; }
    .vizInfo { font-size: 15px; font-weight: 600; }
    .vizCanvasWrap {
      background: #fff; border-radius: 14px; box-shadow: inset 0 0 0 1px #eee;
      overflow: hidden; display:flex;
    }
    canvas { width: 100%; height: 100%; display:block; background: white; }
    .vizBottom { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: center; }
    .pill { padding: 8px 12px; background:#f0f0f1; border-radius: 999px; font-size: 13px; color:#222; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card" id="setupCard">
      <h1>T√§rning eller Klocka</h1>

      <div class="row">
        <div class="col">
          <label><input type="radio" name="mode" value="dice" checked> Sl√• t√§rning</label>
          <label><input type="radio" name="mode" value="clock"> Visa klocka (slumpad tid)</label>
        </div>

        <div class="col" style="margin-left:auto;">
          <!-- DEFAULT: AVBOCKAD -->
          <label><input id="showAnswer" type="checkbox"> Visa facit (summa / klockslag)</label>
          <div class="hint">Ljud spelas n√§r du trycker p√• knappar (webbl√§sare kr√§ver anv√§ndarklick).</div>
        </div>
      </div>

      <div class="spacer"></div>

      <div class="row" id="diceOptions">
        <label>Antal t√§rningar:</label>
        <input id="numDice" type="number" min="1" max="24" value="2" />
      </div>

      <div class="row hidden" id="clockOptions">
        <label>Minutintervall:</label>
        <select id="interval">
          <option>1</option>
          <option selected>5</option>
          <option>10</option>
          <option>15</option>
          <option>20</option>
          <option>30</option>
          <option>60</option>
        </select>
      </div>

      <div class="spacer"></div>
      <div class="row">
        <button id="openBtn">√ñppna</button>
      </div>

      <div class="hint">Tips: P√• mobilen kan du rotera sk√§rmen. Du kan ocks√• anv√§nda helsk√§rmsknappen i visualiseringen.</div>
    </div>

    <div class="card hidden" id="vizCard">
      <div class="vizWrap">
        <div class="vizTop">
          <div class="vizInfo" id="vizTitle">‚Äî</div>
          <div class="row">
            <span class="pill" id="answerPill">Facit: (dolt)</span>
            <button class="secondary" id="fullscreenBtn">Helsk√§rm</button>
            <button class="secondary" id="backBtn">Tillbaka</button>
          </div>
        </div>

        <div class="vizCanvasWrap" id="canvasContainer">
          <canvas id="canvas"></canvas>
        </div>

        <div class="vizBottom">
          <button id="actionBtn">‚Äî</button>
          <button class="secondary" id="surpriseBtn">√ñverraskning üéÅ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Ljud (l√§gg dina filer i sounds/) -->
  <audio id="diceAudio" preload="auto">
    <source src="sounds/dice.wav" type="audio/wav">
  </audio>
  <audio id="clockAudio" preload="auto">
    <source src="sounds/clock.wav" type="audio/wav">
  </audio>

<script>
(() => {
  // ---------- State ----------
  let mode = "dice";
  let showAnswer = document.getElementById("showAnswer").checked;

  // Dice state
  let diceN = 2;
  let diceValues = [];
  let diceAnim = null;

  // Clock state
  let interval = 5;
  let clockTime = { h: 0, m: 0 }; // 0-11, 0-59
  let clockAngles = { hour: -Math.PI/2, min: -Math.PI/2 };
  let clockAnim = null;

  // Surprise state (endast: magic + freeze)
  let surpriseAnim = null;
  let surpriseState = { type: null, t0: 0, duration: 0, magicIndex: 0 };

  // ---------- Elements ----------
  const setupCard = document.getElementById("setupCard");
  const vizCard = document.getElementById("vizCard");
  const diceOptions = document.getElementById("diceOptions");
  const clockOptions = document.getElementById("clockOptions");

  const openBtn = document.getElementById("openBtn");
  const backBtn = document.getElementById("backBtn");
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const actionBtn = document.getElementById("actionBtn");
  const surpriseBtn = document.getElementById("surpriseBtn");

  const showAnswerEl = document.getElementById("showAnswer");
  const numDiceEl = document.getElementById("numDice");
  const intervalEl = document.getElementById("interval");

  const vizTitle = document.getElementById("vizTitle");
  const answerPill = document.getElementById("answerPill");

  const canvasContainer = document.getElementById("canvasContainer");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const diceAudio = document.getElementById("diceAudio");
  const clockAudio = document.getElementById("clockAudio");
  let clockStopTimer = null;

  // ---------- Helpers ----------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function resizeCanvasToContainer() {
    const rect = canvasContainer.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }

  function playAudio(audioEl) {
    try {
      audioEl.pause();
      audioEl.currentTime = 0;
      audioEl.play().catch(()=>{});
    } catch {}
  }

  function stopAudio(audioEl) {
    try { audioEl.pause(); audioEl.currentTime = 0; } catch {}
  }

  function setFacit(text) {
    if (!showAnswer) {
      answerPill.textContent = "Facit: (dolt)";
      return;
    }
    answerPill.textContent = "Facit: " + text;
  }

  function stopAllAnimations() {
    if (diceAnim) cancelAnimationFrame(diceAnim);
    if (clockAnim) cancelAnimationFrame(clockAnim);
    diceAnim = null;
    clockAnim = null;
  }

  function stopSurprise() {
    if (surpriseAnim) cancelAnimationFrame(surpriseAnim);
    surpriseAnim = null;
    surpriseState.type = null;
  }

  // ---------- UI wiring ----------
  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener("change", () => {
      mode = document.querySelector('input[name="mode"]:checked').value;
      diceOptions.classList.toggle("hidden", mode !== "dice");
      clockOptions.classList.toggle("hidden", mode !== "clock");
    });
  });

  showAnswerEl.addEventListener("change", () => {
    showAnswer = !!showAnswerEl.checked;
    if (!vizCard.classList.contains("hidden")) {
      if (mode === "dice") setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
      else setFacit(formatTime(clockTime));
    } else {
      setFacit("‚Äî");
    }
  });

  numDiceEl.addEventListener("change", () => {
    diceN = clamp(parseInt(numDiceEl.value || "2", 10), 1, 24);
    numDiceEl.value = diceN;
  });

  intervalEl.addEventListener("change", () => {
    interval = parseInt(intervalEl.value, 10);
  });

  openBtn.addEventListener("click", () => {
    showAnswer = !!showAnswerEl.checked;
    diceN = clamp(parseInt(numDiceEl.value || "2", 10), 1, 24);
    interval = parseInt(intervalEl.value, 10);

    setupCard.classList.add("hidden");
    vizCard.classList.remove("hidden");

    resizeCanvasToContainer();
    stopAllAnimations();
    stopSurprise();
    if (mode === "dice") startDiceView();
    else startClockView();
  });

  // FIX: l√§mna fullscreen innan vi g√•r tillbaka (annars kan UI "l√•sa")
  backBtn.addEventListener("click", async () => {
    stopAllAnimations();
    stopSurprise();

    if (document.fullscreenElement) {
      try { await document.exitFullscreen(); } catch {}
    }

    setupCard.classList.remove("hidden");
    vizCard.classList.add("hidden");
  });

  fullscreenBtn.addEventListener("click", async () => {
    try {
      if (!document.fullscreenElement) {
        await vizCard.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    } catch {}
  });

  window.addEventListener("resize", () => {
    if (!vizCard.classList.contains("hidden")) {
      resizeCanvasToContainer();
      redraw();
    }
  });

  // Surprise button (endast 2 effekter)
  surpriseBtn.addEventListener("click", () => {
    stopAllAnimations();
    stopSurprise();
    if (mode === "dice") runMagicDice();
    else runFreeze();
  });

  // ---------- Dice ----------
  function startDiceView() {
    vizTitle.textContent = "T√§rningar";
    actionBtn.textContent = "Sl√• igen";
    diceValues = Array.from({length: diceN}, () => randInt(1,6));
    setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
    redraw();

    actionBtn.onclick = () => rollDiceAnimated();
  }

  function rollDiceAnimated() {
    stopAllAnimations();
    stopSurprise();
    playAudio(diceAudio);

    const duration = 950; // ms
    const start = performance.now();
    const final = Array.from({length: diceN}, () => randInt(1,6));

    function frame(t) {
      const p = clamp((t - start)/duration, 0, 1);
      const ease = 1 - (1 - p)*(1 - p);

      if (p < 1) diceValues = Array.from({length: diceN}, () => randInt(1,6));
      else diceValues = final;

      const jitter = (1 - ease);
      const bounce = Math.abs(Math.sin(p * Math.PI * 3)) * (1 - ease);

      redraw({ diceJitter: jitter, diceBounce: bounce });

      if (p < 1) diceAnim = requestAnimationFrame(frame);
      else {
        diceAnim = null;
        setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
        redraw();
      }
    }
    diceAnim = requestAnimationFrame(frame);
  }

  function drawDie(x, y, size, value, jitterScale, bounceScale, popScale) {
    const j = (size * 0.08) * (jitterScale || 0);
    const dx = (Math.random()*2 - 1) * j;
    const dy = (Math.random()*2 - 1) * j;

    const b = (size * 0.14) * (bounceScale || 0); // studs upp√•t
    const dy2 = dy - b;

    const pop = (popScale || 0); // 0..1
    const scale = 1 + 0.10 * pop; // liten "pop"
    const s2 = size * scale;

    // centrera skalning runt die
    const px = x - (s2 - size)/2;
    const py = y - (s2 - size)/2;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.07)";
    roundRect(px+6+dx, py+6+dy2, s2, s2, s2*0.12, true, false);

    // body
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = Math.max(2, s2/40);
    roundRect(px+dx, py+dy2, s2, s2, s2*0.12, true, true);

    // pips
    const margin = s2 * 0.22;
    const cx = [px+dx+margin, px+dx+s2/2, px+dx+s2-margin];
    const cy = [py+dy2+margin, py+dy2+s2/2, py+dy2+s2-margin];
    const r = Math.max(2, s2*0.06);

    const pips = {
      1: [[1,1]],
      2: [[0,0],[2,2]],
      3: [[0,0],[1,1],[2,2]],
      4: [[0,0],[2,0],[0,2],[2,2]],
      5: [[0,0],[2,0],[1,1],[0,2],[2,2]],
      6: [[0,0],[2,0],[0,1],[2,1],[0,2],[2,2]],
    }[value] || [];

    ctx.fillStyle = "black";
    for (const [ix,iy] of pips) {
      ctx.beginPath();
      ctx.arc(cx[ix], cy[iy], r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function layoutDice() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const n = diceN;

    let cols = Math.ceil(Math.sqrt(n));
    let rows = Math.ceil(n / cols);

    const base = Math.min(w, h);

    // √ñKAD SPACING
    const gap = Math.max(26, base * 0.045);
    const margin = Math.max(12, base * 0.05);

    const size = Math.floor(Math.min(
      (w - 2*margin - (cols-1)*gap)/cols,
      (h - 2*margin - (rows-1)*gap)/rows
    ));
    const dieSize = clamp(size, 60, 700);

    const blockW = cols*dieSize + (cols-1)*gap;
    const blockH = rows*dieSize + (rows-1)*gap;
    const baseX = (w - blockW)/2;
    const baseY = (h - blockH)/2;

    return { w, h, cols, rows, gap, margin, dieSize, baseX, baseY };
  }

  // --- Surprise: Magic Dice ---
  function runMagicDice() {
    if (diceN <= 0) return;

    // liten ‚Äútada‚Äù: v√§lj en t√§rning
    surpriseState = {
      type: "magic",
      t0: performance.now(),
      duration: 900,
      magicIndex: randInt(0, diceN - 1)
    };

    function frame(t) {
      const p = clamp((t - surpriseState.t0)/surpriseState.duration, 0, 1);
      redraw({ surprise: surpriseState, surpriseP: p });
      if (p < 1) surpriseAnim = requestAnimationFrame(frame);
      else stopSurprise();
    }
    surpriseAnim = requestAnimationFrame(frame);
  }

  // ---------- Clock ----------
  function startClockView() {
    vizTitle.textContent = "Klocka";
    actionBtn.textContent = "Slumpa ny tid";

    clockTime = randomTime(interval);
    setClockAnglesInstant(clockTime);
    setFacit(formatTime(clockTime));
    redraw();

    actionBtn.onclick = () => newClockTimeAnimated();
  }

  function randomTime(interval) {
    const h = randInt(0, 11);
    const steps = Math.floor(60 / interval);
    const m = randInt(0, steps-1) * interval;
    return { h, m };
  }

  function formatTime(t) {
    let hh = t.h % 12;
    if (hh === 0) hh = 12;
    return String(hh).padStart(2,"0") + ":" + String(t.m).padStart(2,"0");
  }

  function setClockAnglesInstant(t) {
    const minAng = clampAngle(-Math.PI/2 + (t.m/60)*Math.PI*2);
    const hourAng = clampAngle(-Math.PI/2 + ((t.h%12)/12)*Math.PI*2 + (t.m/60)*(Math.PI*2/12));
    clockAngles.min = minAng;
    clockAngles.hour = hourAng;
  }

  function clampAngle(a) {
    const two = Math.PI*2;
    a = a % two;
    if (a < 0) a += two;
    return a;
  }

  function clockwiseDelta(start, target) {
    start = clampAngle(start);
    target = clampAngle(target);
    return (target - start + Math.PI*2) % (Math.PI*2);
  }

  function newClockTimeAnimated() {
    stopAllAnimations();
    stopSurprise();

    playAudio(clockAudio);
    if (clockStopTimer) clearTimeout(clockStopTimer);
    clockStopTimer = setTimeout(() => stopAudio(clockAudio), 2000);

    const newT = randomTime(interval);

    const targetMin = clampAngle(-Math.PI/2 + (newT.m/60)*Math.PI*2);
    const targetHour = clampAngle(-Math.PI/2 + ((newT.h%12)/12)*Math.PI*2 + (newT.m/60)*(Math.PI*2/12));

    const startMin = clockAngles.min;
    const startHour = clockAngles.hour;

    const dMin = clockwiseDelta(startMin, targetMin);
    const dHour = clockwiseDelta(startHour, targetHour);

    const duration = 2000;
    const start = performance.now();

    function frame(t) {
      const p = clamp((t - start)/duration, 0, 1);
      const ease = 1 - (1 - p)*(1 - p);

      clockAngles.min = clampAngle(startMin + dMin*ease);
      clockAngles.hour = clampAngle(startHour + dHour*ease);

      redraw();

      if (p < 1) clockAnim = requestAnimationFrame(frame);
      else {
        clockAnim = null;
        clockTime = newT;
        setFacit(formatTime(clockTime));
      }
    }
    clockAnim = requestAnimationFrame(frame);
  }

  function drawClock() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const size = Math.min(w, h);

    const cx = w/2, cy = h/2;
    const r = size * 0.42;

    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    for (let i=0; i<12; i++) {
      const ang = -Math.PI/2 + i*(Math.PI*2/12);
      const x1 = cx + (r*0.88)*Math.cos(ang);
      const y1 = cy + (r*0.88)*Math.sin(ang);
      const x2 = cx + (r*0.98)*Math.cos(ang);
      const y2 = cy + (r*0.98)*Math.sin(ang);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.stroke();

      const num = ((i + 11) % 12) + 1;
      const tx = cx + (r*0.72)*Math.cos(ang);
      const ty = cy + (r*0.72)*Math.sin(ang);
      ctx.fillStyle = "#111";
      ctx.font = `${Math.max(12, r*0.10)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(num), tx, ty);
    }

    ctx.strokeStyle = "#111";
    ctx.lineCap = "round";

    ctx.lineWidth = Math.max(4, r/18);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + (r*0.55)*Math.cos(clockAngles.hour),
               cy + (r*0.55)*Math.sin(clockAngles.hour));
    ctx.stroke();

    ctx.lineWidth = Math.max(3, r/24);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + (r*0.80)*Math.cos(clockAngles.min),
               cy + (r*0.80)*Math.sin(clockAngles.min));
    ctx.stroke();

    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(cx, cy, 6, 0, Math.PI*2);
    ctx.fill();
  }

  // --- Surprise: Freeze ---
  function runFreeze() {
    surpriseState = { type: "freeze", t0: performance.now(), duration: 900, magicIndex: 0 };

    function frame(t) {
      const p = clamp((t - surpriseState.t0)/surpriseState.duration, 0, 1);
      redraw({ surprise: surpriseState, surpriseP: p });
      if (p < 1) surpriseAnim = requestAnimationFrame(frame);
      else stopSurprise();
    }
    surpriseAnim = requestAnimationFrame(frame);
  }

  // ---------- Rendering ----------
  function redraw(opts = {}) {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    ctx.clearRect(0,0,w,h);

    if (mode === "dice") {
      const L = layoutDice();
      const n = diceN;
      const cols = L.cols;

      const fullRows = Math.floor(n / cols);
      const lastCount = n % cols;

      const jitterScale = (opts.diceJitter ?? 0);
      const bounceScale = (opts.diceBounce ?? 0);

      // magic settings
      const s = opts.surprise;
      const sp = opts.surpriseP;
      const isMagic = (s && s.type === "magic" && sp != null);
      const magicIdx = isMagic ? s.magicIndex : -1;

      for (let i=0; i<n; i++) {
        const row = Math.floor(i/cols);
        const col = i % cols;

        let rowBaseX = L.baseX;
        if (lastCount !== 0 && row === fullRows) {
          const lastW = lastCount * L.dieSize + (lastCount - 1) * L.gap;
          rowBaseX = (L.w - lastW)/2;
        }

        const x = rowBaseX + col*(L.dieSize + L.gap);
        const y = L.baseY + row*(L.dieSize + L.gap);

        // pop scale for magic die (snabbt upp, sen ner)
        let pop = 0;
        if (isMagic && i === magicIdx) {
          const up = Math.sin(sp * Math.PI); // 0..1..0
          pop = up;
        }

        drawDie(x, y, L.dieSize, diceValues[i] ?? 1, jitterScale, bounceScale, pop);
      }
    } else {
      drawClock();
    }

    // overlays
    if (opts.surprise && opts.surpriseP != null) {
      drawSurpriseOverlay(opts.surprise, opts.surpriseP);
    }
  }

  function drawSurpriseOverlay(s, p) {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);

    if (s.type === "freeze") {
      // Frost overlay (mild, snabbt)
      const strength = 0.22 * (1 - Math.abs(0.5 - p)*2); // peak i mitten
      ctx.save();
      ctx.globalAlpha = strength;
      ctx.fillStyle = "#6aa9ff";
      ctx.fillRect(0,0,w,h);

      // sm√• iskristaller
      ctx.globalAlpha = strength * 0.9;
      ctx.fillStyle = "#ffffff";
      const count = 90;
      for (let i=0; i<count; i++) {
        const x = (Math.random()*w);
        const y = (Math.random()*h);
        const r = 1 + Math.random()*2.2;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      return;
    }

    if (mode === "dice" && s.type === "magic") {
      const L = layoutDice();
      const i = s.magicIndex;

      const cols = L.cols;
      const row = Math.floor(i/cols);
      const col = i % cols;

      const n = diceN;
      const fullRows = Math.floor(n / cols);
      const lastCount = n % cols;

      let rowBaseX = L.baseX;
      if (lastCount !== 0 && row === fullRows) {
        const lastW = lastCount * L.dieSize + (lastCount - 1) * L.gap;
        rowBaseX = (L.w - lastW)/2;
      }

      const x = rowBaseX + col*(L.dieSize + L.gap);
      const y = L.baseY + row*(L.dieSize + L.gap);

      // glow box + "sparkles"
      const alpha = 0.55 * (1 - p);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = "#ffd54a";
      ctx.lineWidth = Math.max(3, L.dieSize/18);
      roundRect(x-10, y-10, L.dieSize+20, L.dieSize+20, L.dieSize*0.18, false, true);

      // sparkles
      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = "#ffd54a";
      for (let k=0; k<18; k++) {
        const sx = x + Math.random()*L.dieSize;
        const sy = y + Math.random()*L.dieSize;
        ctx.fillRect(sx, sy, 2, 2);
      }
      ctx.restore();
    }
  }

  function roundRect(x, y, w, h, r, fill, stroke) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

})();
</script>
</body>
</html>
