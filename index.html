<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tärning eller Klocka</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f6f7; color: #111; }
    .app { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .card { background: #fff; border-radius: 14px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.06); }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    label { font-size: 14px; }
    input[type="number"], select {
      font-size: 14px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 10px; background: #fff;
    }
    button {
      font-size: 14px; padding: 10px 14px; border: 0; border-radius: 12px; background: #111; color: #fff;
      cursor: pointer;
    }
    button.secondary { background: #e9e9ea; color: #111; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .hint { color: #666; font-size: 13px; margin-top: 8px; }
    .spacer { height: 10px; }
    .hidden { display: none !important; }

    /* Visualization */
    .vizWrap {
      margin-top: 14px;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      height: min(78vh, 760px);
    }
    .vizTop { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; }
    .vizInfo { font-size: 15px; font-weight: 600; }
    .vizCanvasWrap {
      background: #fff; border-radius: 14px; box-shadow: inset 0 0 0 1px #eee;
      overflow: hidden; display:flex;
    }
    canvas { width: 100%; height: 100%; display:block; background: white; }
    .vizBottom { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: center; }
    .pill { padding: 8px 12px; background:#f0f0f1; border-radius: 999px; font-size: 13px; color:#222; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card" id="setupCard">
      <h1>Tärning eller Klocka</h1>

      <div class="row">
        <div class="col">
          <label><input type="radio" name="mode" value="dice" checked> Slå tärning</label>
          <label><input type="radio" name="mode" value="clock"> Visa klocka (slumpad tid)</label>
          <label><input type="radio" name="mode" value="numberline"> Visa talrad</label>
        </div>

        <div class="col" style="margin-left:auto;">
          <!-- DEFAULT: AVBOCKAD -->
          <label><input id="showAnswer" type="checkbox"> Visa facit (summa / klockslag)</label>
          <div class="hint">Ljud spelas när du trycker på knappar (webbläsare kräver användarklick).</div>
        </div>
      </div>

      <div class="spacer"></div>

      <div class="row" id="diceOptions">
        <label>Antal tärningar:</label>
        <input id="numDice" type="number" min="1" max="24" value="2" />
      </div>

      <div class="row hidden" id="clockOptions">
        <label>Minutintervall:</label>
        <select id="interval">
          <option>1</option>
          <option selected>5</option>
          <option>10</option>
          <option>15</option>
          <option>20</option>
          <option>30</option>
          <option>60</option>
        </select>
      </div>

      <div class="row hidden" id="numberlineOptions">
        <label>Talrad från:</label>
        <input id="nlMin" type="number" value="0" style="width:90px" />
        <label>till:</label>
        <input id="nlMax" type="number" value="10" style="width:90px" />
        <span class="hint" style="margin:0">Tips: t.ex. -10 till 10</span>
      </div>


      <div class="spacer"></div>
      <div class="row">
        <button id="openBtn">Öppna</button>
      </div>

      <div class="hint">Tips: På mobilen kan du rotera skärmen. Du kan också använda helskärmsknappen i visualiseringen.</div>
    </div>

    <div class="card hidden" id="vizCard">
      <div class="vizWrap">
        <div class="vizTop">
          <div class="vizInfo" id="vizTitle">—</div>
          <div class="row">
            <span class="pill" id="answerPill">Facit: (dolt)</span>
            <button class="secondary" id="fullscreenBtn">Helskärm</button>
            <button class="secondary" id="backBtn">Tillbaka</button>
          </div>
        </div>

        <div class="vizCanvasWrap" id="canvasContainer">
          <canvas id="canvas"></canvas>
        </div>

        <div class="vizBottom">
        <button id="actionBtn">—</button>
        <button class="secondary" id="leftBtn">←</button>
        <button class="secondary" id="rightBtn">→</button>
      </div>
      </div>
    </div>
  </div>

  <!-- Ljud (lägg dina filer i sounds/) -->
  <audio id="diceAudio" preload="auto">
    <source src="sounds/dice.wav" type="audio/wav">
  </audio>
  <audio id="clockAudio" preload="auto">
    <source src="sounds/clock.wav" type="audio/wav">
  </audio>

<script>
(() => {
  // ---------- State ----------
  let mode = "dice";
  let showAnswer = document.getElementById("showAnswer").checked;

  // Dice state
  let diceN = 2;
  let diceValues = [];
  let diceAnim = null;

  // Clock state
  let interval = 5;
  let clockTime = { h: 0, m: 0 }; // 0-11, 0-59
  let clockAngles = { hour: -Math.PI/2, min: -Math.PI/2 };
  let clockAnim = null;

  // Number line state
  let nlDisplayValue = 0;
  let nlMin = 0;
  let nlMax = 10;
  let nlValue = 0;
  let nlAnim = null;
  let nlAnimState = null; // {from,to,t0,duration}

  // ---------- Elements ----------
  const setupCard = document.getElementById("setupCard");
  const vizCard = document.getElementById("vizCard");
  const diceOptions = document.getElementById("diceOptions");
  const clockOptions = document.getElementById("clockOptions");
  const numberlineOptions = document.getElementById("numberlineOptions");

  const openBtn = document.getElementById("openBtn");
  const backBtn = document.getElementById("backBtn");
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const actionBtn = document.getElementById("actionBtn");
  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");


  const showAnswerEl = document.getElementById("showAnswer");
  const numDiceEl = document.getElementById("numDice");
  const intervalEl = document.getElementById("interval");
  const nlMinEl = document.getElementById("nlMin");
  const nlMaxEl = document.getElementById("nlMax");

  const vizTitle = document.getElementById("vizTitle");
  const answerPill = document.getElementById("answerPill");

  const canvasContainer = document.getElementById("canvasContainer");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const diceAudio = document.getElementById("diceAudio");
  const clockAudio = document.getElementById("clockAudio");
  let clockStopTimer = null;

  // ---------- Helpers ----------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function resizeCanvasToContainer() {
    const rect = canvasContainer.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }

  function playAudio(audioEl) {
    try {
      audioEl.pause();
      audioEl.currentTime = 0;
      audioEl.play().catch(()=>{});
    } catch {}
  }

  function stopAudio(audioEl) {
    try { audioEl.pause(); audioEl.currentTime = 0; } catch {}
  }

  function setFacit(text) {
    if (!showAnswer) {
      answerPill.textContent = "Facit: (dolt)";
      return;
    }
    answerPill.textContent = "Facit: " + text;
  }

  // ---------- UI wiring ----------
  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener("change", () => {
      mode = document.querySelector('input[name="mode"]:checked').value;
      diceOptions.classList.toggle("hidden", mode !== "dice");
      clockOptions.classList.toggle("hidden", mode !== "clock");
      numberlineOptions.classList.toggle("hidden", mode !== "numberline");
    });
  });

  showAnswerEl.addEventListener("change", () => {
    showAnswer = !!showAnswerEl.checked;

    if (!vizCard.classList.contains("hidden")) {
      if (mode === "dice") setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
      else if (mode === "clock") setFacit(formatTime(clockTime));
      else setFacit(String(nlValue));
    } else {
      setFacit("—");
    }
  });


  numDiceEl.addEventListener("change", () => {
    diceN = clamp(parseInt(numDiceEl.value || "2", 10), 1, 24);
    numDiceEl.value = diceN;
  });

  intervalEl.addEventListener("change", () => {
    interval = parseInt(intervalEl.value, 10);
  });

  openBtn.addEventListener("click", () => {
    showAnswer = !!showAnswerEl.checked;
    diceN = clamp(parseInt(numDiceEl.value || "2", 10), 1, 24);
    interval = parseInt(intervalEl.value, 10);
    if (mode === "numberline") {
      let a = parseInt(nlMinEl.value || "0", 10);
      let b = parseInt(nlMaxEl.value || "20", 10);

      if (Number.isNaN(a)) a = 0;
      if (Number.isNaN(b)) b = 20;

      // om användaren skriver "fel" ordning
      if (a > b) [a, b] = [b, a];

      // begränsa så det inte blir extremt (valfritt, men bra)
      a = clamp(a, -200, 200);
      b = clamp(b, -200, 200);

      // minst 1 steg
      if (a === b) b = a + 1;

      nlMin = a;
      nlMax = b;

      // skriv tillbaka (så UI visar vad som faktiskt gäller)
      nlMinEl.value = String(nlMin);
      nlMaxEl.value = String(nlMax);
    }



    setupCard.classList.add("hidden");
    vizCard.classList.remove("hidden");

    resizeCanvasToContainer();
    if (mode === "dice") startDiceView();
    else if (mode === "clock") startClockView();
    else startNumberLineView();

  });

  // FIX: lämna fullscreen innan vi går tillbaka (annars kan UI "låsa")
  backBtn.addEventListener("click", async () => {
    stopAllAnimations();
    stopNumberlineAnim();

    if (document.fullscreenElement) {
      try { await document.exitFullscreen(); } catch {}
    }

    setupCard.classList.remove("hidden");
    vizCard.classList.add("hidden");
  });

  fullscreenBtn.addEventListener("click", async () => {
    try {
      if (!document.fullscreenElement) {
        await vizCard.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    } catch {}
  });

  window.addEventListener("resize", () => {
    if (!vizCard.classList.contains("hidden")) {
      resizeCanvasToContainer();
      redraw();
    }
  });

  window.addEventListener("keydown", (e) => {
    if (vizCard.classList.contains("hidden")) return;
    if (mode !== "numberline") return;

    if (e.key === "ArrowLeft") { e.preventDefault(); moveNumberLine(-1); }
    if (e.key === "ArrowRight") { e.preventDefault(); moveNumberLine(+1); }
  });

  // Swipe för talrad (mobil/surfplatta)
  let touchStartX = null;

  canvas.addEventListener("touchstart", (e) => {
    if (vizCard.classList.contains("hidden")) return;
    if (mode !== "numberline") return;
    touchStartX = e.touches[0].clientX;
  }, { passive: true });

  canvas.addEventListener("touchend", (e) => {
    if (vizCard.classList.contains("hidden")) return;
    if (mode !== "numberline") return;
    if (touchStartX == null) return;

    const endX = e.changedTouches[0].clientX;
    const dx = endX - touchStartX;
    touchStartX = null;

    if (Math.abs(dx) < 25) return; // ignore små svep

    if (dx < 0) moveNumberLine(-1);
    else moveNumberLine(+1);
  }, { passive: true });


  // ---------- Dice ----------
  function startDiceView() {
    leftBtn.classList.add("hidden");
    rightBtn.classList.add("hidden");
    vizTitle.textContent = "Tärningar";
    actionBtn.textContent = "Slå igen";
    diceValues = Array.from({length: diceN}, () => randInt(1,6));
    setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
    redraw();

    actionBtn.onclick = () => rollDiceAnimated();
  }

  function rollDiceAnimated() {
    stopAllAnimations();
    playAudio(diceAudio);

    const duration = 950; // ms
    const start = performance.now();
    const final = Array.from({length: diceN}, () => randInt(1,6));

    function frame(t) {
      const p = clamp((t - start)/duration, 0, 1);
      const ease = 1 - (1 - p)*(1 - p);

      if (p < 1) diceValues = Array.from({length: diceN}, () => randInt(1,6));
      else diceValues = final;

      // jitter + bounce
      const jitter = (1 - ease);
      const bounce = Math.abs(Math.sin(p * Math.PI * 3)) * (1 - ease);

      redraw({ diceJitter: jitter, diceBounce: bounce });

      if (p < 1) diceAnim = requestAnimationFrame(frame);
      else {
        diceAnim = null;
        setFacit(String(diceValues.reduce((a,b)=>a+b,0)));
        redraw(); // final crisp redraw
      }
    }
    diceAnim = requestAnimationFrame(frame);
  }

  function drawDie(x, y, size, value, jitterScale, bounceScale) {
    const j = (size * 0.08) * (jitterScale || 0);
    const dx = (Math.random()*2 - 1) * j;
    const dy = (Math.random()*2 - 1) * j;

    const b = (size * 0.14) * (bounceScale || 0); // studs uppåt
    const dy2 = dy - b;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.07)";
    roundRect(x+6+dx, y+6+dy2, size, size, size*0.12, true, false);

    // body
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = Math.max(2, size/40);
    roundRect(x+dx, y+dy2, size, size, size*0.12, true, true);

    // pips
    const margin = size * 0.22;
    const cx = [x+dx+margin, x+dx+size/2, x+dx+size-margin];
    const cy = [y+dy2+margin, y+dy2+size/2, y+dy2+size-margin];
    const r = Math.max(2, size*0.06);

    const pips = {
      1: [[1,1]],
      2: [[0,0],[2,2]],
      3: [[0,0],[1,1],[2,2]],
      4: [[0,0],[2,0],[0,2],[2,2]],
      5: [[0,0],[2,0],[1,1],[0,2],[2,2]],
      6: [[0,0],[2,0],[0,1],[2,1],[0,2],[2,2]],
    }[value] || [];

    ctx.fillStyle = "black";
    for (const [ix,iy] of pips) {
      ctx.beginPath();
      ctx.arc(cx[ix], cy[iy], r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function layoutDice() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const n = diceN;

    // välj grid nära kvadrat
    let cols = Math.ceil(Math.sqrt(n));
    let rows = Math.ceil(n / cols);

    const base = Math.min(w, h);

    // ÖKAD SPACING
    const gap = Math.max(24, base * 0.04);
    const margin = Math.max(12, base * 0.05);

    const size = Math.floor(Math.min(
      (w - 2*margin - (cols-1)*gap)/cols,
      (h - 2*margin - (rows-1)*gap)/rows
    ));
    const dieSize = clamp(size, 60, 700);

    // block size and centering
    const blockW = cols*dieSize + (cols-1)*gap;
    const blockH = rows*dieSize + (rows-1)*gap;
    const baseX = (w - blockW)/2;
    const baseY = (h - blockH)/2;

    return { w, h, cols, rows, gap, margin, dieSize, baseX, baseY };
  }

  // ---------- Clock ----------
  function startClockView() {
    leftBtn.classList.add("hidden");
    rightBtn.classList.add("hidden");
    vizTitle.textContent = "Klocka";
    actionBtn.textContent = "Slumpa ny tid";

    clockTime = randomTime(interval);
    setClockAnglesInstant(clockTime);
    setFacit(formatTime(clockTime));
    redraw();

    actionBtn.onclick = () => newClockTimeAnimated();
  }

  function randomTime(interval) {
    const h = randInt(0, 11);
    const steps = Math.floor(60 / interval);
    const m = randInt(0, steps-1) * interval;
    return { h, m };
  }

  function formatTime(t) {
    let hh = t.h % 12;
    if (hh === 0) hh = 12;
    return String(hh).padStart(2,"0") + ":" + String(t.m).padStart(2,"0");
  }

  function setClockAnglesInstant(t) {
    const minAng = clampAngle(-Math.PI/2 + (t.m/60)*Math.PI*2);
    const hourAng = clampAngle(-Math.PI/2 + ((t.h%12)/12)*Math.PI*2 + (t.m/60)*(Math.PI*2/12));
    clockAngles.min = minAng;
    clockAngles.hour = hourAng;
  }

  function clampAngle(a) {
    const two = Math.PI*2;
    a = a % two;
    if (a < 0) a += two;
    return a;
  }

  function clockwiseDelta(start, target) {
    start = clampAngle(start);
    target = clampAngle(target);
    return (target - start + Math.PI*2) % (Math.PI*2);
  }

  function newClockTimeAnimated() {
    stopAllAnimations();

    playAudio(clockAudio);
    if (clockStopTimer) clearTimeout(clockStopTimer);
    clockStopTimer = setTimeout(() => stopAudio(clockAudio), 2000);

    const newT = randomTime(interval);

    const targetMin = clampAngle(-Math.PI/2 + (newT.m/60)*Math.PI*2);
    const targetHour = clampAngle(-Math.PI/2 + ((newT.h%12)/12)*Math.PI*2 + (newT.m/60)*(Math.PI*2/12));

    const startMin = clockAngles.min;
    const startHour = clockAngles.hour;

    const dMin = clockwiseDelta(startMin, targetMin);
    const dHour = clockwiseDelta(startHour, targetHour);

    const duration = 2000;
    const start = performance.now();

    function frame(t) {
      const p = clamp((t - start)/duration, 0, 1);
      const ease = 1 - (1 - p)*(1 - p);

      clockAngles.min = clampAngle(startMin + dMin*ease);
      clockAngles.hour = clampAngle(startHour + dHour*ease);

      redraw();

      if (p < 1) clockAnim = requestAnimationFrame(frame);
      else {
        clockAnim = null;
        clockTime = newT;
        setFacit(formatTime(clockTime));
      }
    }
    clockAnim = requestAnimationFrame(frame);
  }

  function drawClock() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const size = Math.min(w, h);

    const cx = w/2, cy = h/2;
    const r = size * 0.42;

    // face
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // markers + numbers (12 up)
    for (let i=0; i<12; i++) {
      const ang = -Math.PI/2 + i*(Math.PI*2/12);
      const x1 = cx + (r*0.88)*Math.cos(ang);
      const y1 = cy + (r*0.88)*Math.sin(ang);
      const x2 = cx + (r*0.98)*Math.cos(ang);
      const y2 = cy + (r*0.98)*Math.sin(ang);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.stroke();

      const num = ((i + 11) % 12) + 1;
      const tx = cx + (r*0.72)*Math.cos(ang);
      const ty = cy + (r*0.72)*Math.sin(ang);
      ctx.fillStyle = "#111";
      ctx.font = `${Math.max(12, r*0.10)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(num), tx, ty);
    }

    // hour hand
    ctx.strokeStyle = "#e53935";
    ctx.lineCap = "round";
    ctx.lineWidth = Math.max(4, r/18);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + (r*0.42)*Math.cos(clockAngles.hour),
               cy + (r*0.42)*Math.sin(clockAngles.hour));
    ctx.stroke();

    // minute hand
    ctx.strokeStyle = "#1e88e5"
    ctx.lineWidth = Math.max(3, r/24);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + (r*0.62)*Math.cos(clockAngles.min),
               cy + (r*0.62)*Math.sin(clockAngles.min));
    ctx.stroke();

    // center dot
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(cx, cy, 6, 0, Math.PI*2);
    ctx.fill();
  }

  function startNumberLineView() {
  vizTitle.textContent = "Talrad";
  actionBtn.textContent = "Slumpa punkt";

  nlValue = randInt(nlMin, nlMax);
  nlDisplayValue = nlValue;              // ✅ VIKTIGT
  setFacit(String(nlValue));
  redraw();

  leftBtn.classList.remove("hidden");
  rightBtn.classList.remove("hidden");

  leftBtn.onclick = () => moveNumberLine(-1);
  rightBtn.onclick = () => moveNumberLine(+1);

  actionBtn.onclick = () => {
    stopAllAnimations();
    stopNumberlineAnim();
    nlValue = randInt(nlMin, nlMax);
    nlDisplayValue = nlValue;            // ✅ bra (du hade den)
    setFacit(String(nlValue));
    redraw();
  };
}


function stopNumberlineAnim() {
  if (nlAnim) cancelAnimationFrame(nlAnim);
  nlAnim = null;
  nlAnimState = null;
}

function moveNumberLine(step) {
  // Om animation pågår: utgå från nuvarande "display"-värde
  const base = (nlAnimState ? nlDisplayValue : nlValue);

  // vi vill flytta exakt ett helt steg i heltal
  const nextInt = clamp(Math.round(base) + step, nlMin, nlMax);

  if (nlAnimState && nextInt === nlAnimState.to) return;
  if (!nlAnimState && nextInt === nlValue) return;

  animateNumberLineTo(nextInt);
}


function animateNumberLineTo(targetValue) {
  // Om animation pågår: börja från den position som visas JUST NU
  let fromValue = nlValue;

  if (nlAnimState) {
    // beräkna var vi är i den gamla animationen
    const now = performance.now();
    const p = clamp((now - nlAnimState.t0) / nlAnimState.duration, 0, 1);
    const cur = nlAnimState.from + (nlAnimState.to - nlAnimState.from) * p;
    fromValue = cur;
  }

  stopAllAnimations();
  stopNumberlineAnim();

  nlAnimState = {
    from: fromValue,
    to: targetValue,
    t0: performance.now(),
    duration: 220
  };

  function frame(t) {
    const p = clamp((t - nlAnimState.t0) / nlAnimState.duration, 0, 1);

    // smooth
    const ease = 1 - (1 - p) * (1 - p);

    // uppdatera display value kontinuerligt
    nlDisplayValue = nlAnimState.from + (nlAnimState.to - nlAnimState.from) * ease;

    redraw({ nlMoveP: ease, nlFrom: nlAnimState.from, nlTo: nlAnimState.to });

    if (p < 1) nlAnim = requestAnimationFrame(frame);
    else {
      nlValue = targetValue;
      nlDisplayValue = nlValue;
      setFacit(String(nlValue));
      nlAnim = null;
      nlAnimState = null;
      redraw();
    }
  }
  nlAnim = requestAnimationFrame(frame);
}


function numberToX(v, left, right) {
  const t = (v - nlMin) / (nlMax - nlMin);
  return left + t * (right - left);
}

function drawNumberLine(opts = {}) {
  const w = canvas.width / (window.devicePixelRatio || 1);
  const h = canvas.height / (window.devicePixelRatio || 1);

  const padX = Math.max(18, w * 0.08);
  const y = h * 0.55;
  const left = padX;
  const right = w - padX;

  // line
  ctx.strokeStyle = "#111";
  ctx.lineWidth = Math.max(2, Math.min(4, w / 300));
  ctx.beginPath();
  ctx.moveTo(left, y);
  ctx.lineTo(right, y);
  ctx.stroke();

  // ticks
  const tickH = Math.max(10, h * 0.035);
  ctx.lineWidth = Math.max(2, Math.min(3, w / 400));
  ctx.font = `${Math.max(12, Math.min(22, w * 0.03))}px system-ui`;
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  for (let v = nlMin; v <= nlMax; v++) {
    const x = numberToX(v, left, right);

    // längre streck vid 0 och 5-steg, annars kortare
    const isMajor = (v === 0) || (v % 5 === 0);
    const hh = isMajor ? tickH : tickH * 0.65;

    ctx.strokeStyle = "#111";
    ctx.beginPath();
    ctx.moveTo(x, y - hh);
    ctx.lineTo(x, y + hh);
    ctx.stroke();

    // labels (alla heltal om intervallet är <= 25, annars glesa)
    const span = nlMax - nlMin;
    const showLabel = (span <= 25) ? true : isMajor;
    if (showLabel) {
      ctx.fillStyle = "#111";
      ctx.fillText(String(v), x, y + hh + 6);
    }
  }

  // Dot position + parabol-hopp vid rörelse
  const baseVal = (opts.nlMoveP != null ? nlDisplayValue : nlValue);
  let x = numberToX(baseVal, left, right);
  let yOff = 0;

  if (opts.nlMoveP != null) {
    const p = opts.nlMoveP;
    const jump = 4 * p * (1 - p);
    const amp = Math.max(18, h * 0.10);
    yOff = -amp * jump;
  }


  // dot
  const r = Math.max(6, Math.min(14.4, w * 0.016));
  ctx.fillStyle = "#1e88e5";
  ctx.beginPath();
  ctx.arc(x, y + yOff, r, 0, Math.PI * 2);
  ctx.fill();
}

  // ---------- Rendering ----------
  function redraw(opts = {}) {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    ctx.clearRect(0,0,w,h);

    if (mode === "dice") {
      const L = layoutDice();
      const n = diceN;
      const cols = L.cols;

      const fullRows = Math.floor(n / cols);
      const lastCount = n % cols;

      const jitterScale = (opts.diceJitter ?? 0);
      const bounceScale = (opts.diceBounce ?? 0);

      for (let i=0; i<n; i++) {
        const row = Math.floor(i/cols);
        const col = i % cols;

        let rowBaseX = L.baseX;
        if (lastCount !== 0 && row === fullRows) {
          const lastW = lastCount * L.dieSize + (lastCount - 1) * L.gap;
          rowBaseX = (L.w - lastW)/2;
        }

        const x = rowBaseX + col*(L.dieSize + L.gap);
        const y = L.baseY + row*(L.dieSize + L.gap);
        drawDie(x, y, L.dieSize, diceValues[i] ?? 1, jitterScale, bounceScale);
      }
    } else if (mode === "clock") {
    drawClock();
    } else {
      drawNumberLine(opts);
    }
  }

  function stopAllAnimations() {
    if (diceAnim) cancelAnimationFrame(diceAnim);
    if (clockAnim) cancelAnimationFrame(clockAnim);
    diceAnim = null;
    clockAnim = null;
  }

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function roundRect(x, y, w, h, r, fill, stroke) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

})();
</script>
</body>
</html>
